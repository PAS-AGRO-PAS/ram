---
title: "Mixed Farm Optimisation"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Mixed Farm Optimisation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
library(ram)
library(dplyr)
library(tidyr)
library(tibble)
library(stringr)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

In Mediterranean mixed‐farm systems, land and labor are shared between arable crops and livestock enterprises.  The objective of this analysis is to determine the profit‐maximizing allocation of 15 ha of land, 350 h of labor and 400 kg of available nitrogen among four winter crops and a temporary pasture for sheep.  Each crop carries standard agronomic area bounds (e.g. oat between 2 ha and 8 ha), and pasture must lie between 2 ha and 4 ha.  All assumptions are captured in a single specification table so the narrative, code, and Shiny app share one source of truth.

```{r activity-specs}
activity_specs <- tibble::tribble(
  ~activity, ~land, ~labor, ~nitrogen, ~margin, ~min_area, ~max_area,
  "oat",      1,      20,      80,       400,     2,         8,
  "barley",   1,      25,     100,       450,     1,         6,
  "lupin",    1,      15,       0,       350,     2,         5,
  "fava",     1,      30,      30,       500,     1,         3,
  "pasture",  1,      10,       0,       360,     2,         4
)

activity_specs %>%
  mutate(
    activity = stringr::str_to_title(activity),
    area_bounds = paste(min_area, "\u2013", max_area)
  ) %>%
  select(Activity = activity, `Land (ha)` = land, `Labor (h)` = labor,
         `Nitrogen (kg)` = nitrogen, `Margin (€/ha)` = margin,
         `Area bounds (ha)` = area_bounds) %>%
  knitr::kable(caption = "Table 1. Resource requirements, margins, and area bounds for each activity.")
```

We formulate a linear program to maximize total gross margin subject to resource and area constraints.  The following sections describe the model construction, solution, and sensitivity analysis using the `ram` package (the same data ships as the default example inside `ram::run_app(mode = "solve")` or via the builder → solver hand-off).

# Methods

## Define Resource Constraints

We declare the available totals (land, labor, nitrogen) and then derive the per-activity bounds directly from `activity_specs`, ensuring every downstream object stays consistent.

```{r define-resources}
resource_totals <- tibble::tribble(
  ~resource, ~availability, ~direction,
  "land",        15,          "<=",
  "labor",      350,          "<=",
  "nitrogen",   400,          "<="
)

resource_bounds <- activity_specs %>%
  select(activity, min_area, max_area) %>%
  pivot_longer(c(min_area, max_area), names_to = "bound_type", values_to = "availability") %>%
  mutate(
    resource  = paste0(activity, if_else(bound_type == "min_area", "_min", "_max")),
    direction = if_else(bound_type == "min_area", ">=", "<=")
  ) %>%
  select(resource, availability, direction)

resources_tbl <- bind_rows(resource_totals, resource_bounds)

resources <- define_resources(
  resources   = resources_tbl$resource,
  availability = resources_tbl$availability,
  direction    = resources_tbl$direction
)

resources
```

## Specify Activities

The technical matrix mirrors the resource order: totals first, then each activity’s minimum and maximum indicator rows.  Using the specification tibble keeps the code readable.

```{r sepcActivities}
activity_names <- activity_specs$activity

indicator_list <- lapply(activity_names, function(name) {
  vec <- as.numeric(activity_names == name)
  mat <- matrix(vec, nrow = 1, dimnames = list(NULL, activity_names))
  min_row <- mat
  rownames(min_row) <- paste0(name, "_min")
  max_row <- mat
  rownames(max_row) <- paste0(name, "_max")
  rbind(min_row, max_row)
})

bound_rows <- do.call(rbind, indicator_list)

tech_totals <- rbind(
  land     = activity_specs$land,
  labor    = activity_specs$labor,
  nitrogen = activity_specs$nitrogen
)

activity_requirements_matrix <- rbind(tech_totals, bound_rows)
row_order <- resources_tbl$resource
activity_requirements_matrix <- activity_requirements_matrix[row_order, , drop = FALSE]

objective <- activity_specs$margin
names(objective) <- activity_specs$activity

activities <- define_activities(
  activities = activity_names,
  activity_requirements_matrix = activity_requirements_matrix,
  objective = objective
)

activities
```

## Build and Solve the Linear Program

The model is constructed via `create_ram_model()` and solved in the maximization sense with `solve_ram()`.

```{r solveMod}
# Step 3: Build and Solve the Model
model <- create_ram_model(resources, activities)
solution <- solve_ram(model, direction = "max")
```

# Results

## Optimal Allocation

`summary_ram()` consolidates the optimal activities and the objective value; `plot_ram()` provides the accompanying visual.

```{r table}
summary_ram(solution)
```

```{r, fig.width=10, fig.height=5}
plot_ram(solution)
```

## Shadow Prices and Sensitivity

To explore the economic value of relaxing each constraint, we compute the shadow prices via `sensitivity_ram()`. A non‐zero shadow price for a `"≤"` constraint indicates the marginal gain per extra unit of that resource.



### Step 5: Sensitivity Analysis

```{r}
sens <- sensitivity_ram(solution)

DT::datatable(
  sens,
  caption = htmltools::tags$caption(
    style = "caption-side: top; text-align: left;",
    "Table 3. Sensitivity analysis of constraints (shadow prices and allowable ranges)."
  ),
  rownames = FALSE,
  colnames = c(
    "Resource", "Direction", "Availability", 
    "Shadow Price", "Lower Bound", "Upper Bound"
  ),
  options = list(
    pageLength = nrow(sens),
    dom = 't',    # only the table, no extra controls
    columnDefs = list(
      list(className = 'dt-center', targets = 0:5)
    )
  )
) |>
  DT::formatRound(columns = c("availability", "shadow_price", "lower_bound", "upper_bound"), digits = 2)
```


# Conclusion

The sensitivity analysis highlights which constraints are binding at the optimum and therefore command a non-zero shadow price. In this scenario, the minimum area bounds for oat, barley, and lupin are binding (shadow price > 0), implying that allowing an extra hectare of any of those crops would increase the gross margin by the indicated amount. Land, labor, nitrogen, and the remaining bounds exhibit zero prices, signalling slack capacity under the current assumptions.

Because every input stems from `activity_specs`, exploring what-if scenarios is as simple as editing the tibble (or loading alternative CSVs inside `ram::run_app()`). Practitioners can therefore iterate between scripted analyses like this vignette and the interactive builder → solver workflow without re-entering data, ensuring evidence-based decisions remain consistent across tools.
